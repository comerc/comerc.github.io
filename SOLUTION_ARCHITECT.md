# АРХИТЕКТУРНЫЙ ОПЫТ 

Сложно выделить отдельно, но попробую перечислить некоторые активности, где накапливал архитектурный опыт.

- Сессии R&D в режиме live-code на Ютубе в течении 5 лет (1800 трансляций) - выбираю и прокачиваю веб-технологии (GoLang, React, Flutter, Hasura, Temporal, Kafka, AWS).
- Евангелизация GraphQL, как декларативный подход в реализации API. Приёмы кодогенерации на backend и frontend. Исследование "миллион подключений реального времени". 
- Реализация мультисайта на WinterCMS (на PHP), формирование пайплайна на GitLab CI/CD для сборки микрофронтэндов.
- Исследования и MVP генерации саммари для корпоративных видео-встреч на базе Whisper от OpenAI (включая дообучение модели на Python) в сравнении SaluteSpeech и SileroSTT.
- Поиск решений для визуализации динамики ветра на карте и глобусе.
- Предложения по доработкам функционала корпоративного сайта, продающего погодные данные. Обоснование перехода на NextJS и евангелизация Markdown.
- Определение тех-стека для задания по реализации клона fandom.com (wiki-портал для игроков), выбор субподрядчика на конкурсной основе.
- Руководство разработкой клона opensea.io (NFT-маркетплейс).
- Переучёт и перезапуск разработки легаси-продуктов (режим "поднимаю с колен"): на PHP (переход с монолита на гексагональную архитектуру), на GoLang (модульный монолит), на Python (банальная уборка кодовой базы), на React (археологические изыскания), на С++ (переход с монолита на EventSourcing-CQRS в GoLang).
- Оценка сроков реализации проектов от заказчиков на upwork, курирование исполнителей с технической стороны.
- Реализация мультисайта на DrupalCMS (PHP), администирование выделенного сервера, оптимизации и доработки функционала контент-фермы (UGC).
- Выбор решения для каталога товаров маркетплейса, когда переменный набор свойств товаров в категориях (аналог avito.ru и kufar.by).
- Чек-лист улучшений для кратного снижения нагрузки, настройка мониторинга и автоматизация тестирования (на Selenium) в мобильной версии mamba.ru (сервис знакомств).
- Пару раз в роли "мудрый филин", когда я самый давний разработчик. Как передавать экспертизу - попытки внедрения BDD и описание в нотации C4.

## КАКИЕ ЗАДАЧИ ПРЕДСТОИТ РЕШАТЬ

- Проектирование и построение будущей архитектуры системы исходя из стратегических целей компании, имеющихся ресурсов и выявленных пробелов в легаси.
- Участие в формировании необходимых процедур и процессов, направленных на систематическое снижение стоимости архитектуры.
- Обучение инженеров необходимым архитектурным навыкам, повышая общую инженерную зрелость отдела.
- Проработка проектной документации (ADR + NFR), анализ функциональных требований, высокоуровневая эстимация.
- Коммуникации с командами разработки на этапе реализации сервисов.
- Создание предложений по улучшению легаси-системы с учетом техдолга, существующих рисков и перспектив развития.

## НАШИ ОЖИДАНИЯ

- Опыт разработки коммерческого ПО не менее 3 лет (в качестве разработчика).
- Опыт разработки систем или продуктов от 2 лет (в качестве техлида/тимлида/архитектора).
- Знания современных паттернов и подходов к разработке ПО.
- Современный взгляд на архитектуру и технологии, широкий кругозор.
- Умение оформлять документы, знание методов и инструментов создания архитектурных артефактов.
- Знания микросервисных паттернов.
- Понимание внутреннего устройства, опыт внедрения и эксплуатации в продакшене любого из перечисленных NOSQL решений Redis/MongoDB/ElasticSearch/Cassandra.
- Понимание принципов и проблематики масштабирования слоев данных. (master-master/master-slave/no-master)
- Базовые знания в области информационной/кибербезопасности, инфраструктуры, контейнеризации (Docker), доставки кода - CI/CD.

## БУДЕТ ПЛЮСОМ

- Высшее техническое образование.
- Умение читать код и делать ревью хотя бы на одном языке PHP/JS/C++ актуальной версии будет плюсом.
- Успешный (и/или НЕ успешный) практический опыт декомпозиции монолитных приложений и монолитных слоев данных.
- Опыт и понимание разработки в Agile.
- Понимание принципов DDD.
- Понимание внутреннего устройства и практический опыт с одним из брокеров сообщений Kafka/RabbitMQ/RedisStreams.
- Навыки и знания паттернов Data-modelling.
- Опыт работы на смежных позициях (SRE, DevOps, QA).

### Архитектор Решений (справка)

**Solution Architect** — это профессионал, который разрабатывает и управляет реализацией конкретного решения или набора решений внутри организации. Эти решения обычно связаны с программными продуктами или технологическими системами и предназначены для решения конкретных проблем или улучшения определенных процессов в компании.

Обязанности архитектора решений могут включать в себя:

- Предоставление рекомендаций и дорожных карт для предлагаемых решений.
- Проектирование, отладка и анализ производительности решений.
- Документирование и обмен лучшими практиками для новых решений.
- Поддержка процесса улучшения и разработки решений.
- Коммуникация новых функций и преимуществ заказчикам и заинтересованным сторонам.
- Техническое руководство командой на протяжении жизненного цикла проекта.

Важно отметить, что архитектор решений не является менеджером проекта, но для успешной реализации проекта ему необходимы навыки управления проектом, а также ясная коммуникация с нетехническими заинтересованными сторонами.

### Hasura.io (справка)

**Hasura** — это платформа, предоставляющая **мгновенные GraphQL API** на основе ваших данных. Вот некоторые ключевые аспекты:

1. **Мгновенные GraphQL API:** Hasura позволяет вам быстро создавать, управлять и развивать GraphQL API высокого уровня для ваших приложений. Вы можете подключить Hasura к существующим и новым источникам данных и получить API всего за несколько минут.
2. **Суперграф:** Hasura DDN (Data Delivery Network) объединяет все ваши базы данных, сервисы и код в единый граф данных. Этот суперграф предоставляет мощное API с высокой степенью комбинируемости и производительности.
3. **Преимущества:**
  - **Простота:** Создавайте API на своем домене всего за несколько минут.
  - **Стандартизация:** Hasura обеспечивает высокую степень комбинируемости и стандартизированный API.
  - **Высокая производительность:** Оптимизированный запрос к базе данных.
4. **Отзывы пользователей:**
  - “С Hasura мы смогли сократить сроки разработки до года в высокорегулируемой среде, такой как здравоохранение.” — Картик Сринивасан, архитектор решений, Philips Healthcare.
  - “Hasura позволила нам сосредоточиться на бизнес-логике, а не на создании API доступа к данным.” — Питер Даунс, директор по инженерии, Pipe.

Если вам нужны мгновенные GraphQL API, Hasura — отличный выбор!

### Temporal.io (справка)

**Temporal** - это реализация паттерна **Durable Execution** с открытым исходным кодом, мощная абстракция разработки, которая обеспечивает надежное выполнение кода вашего приложения. Вот что вам нужно знать:

1. **Платформа Durable Execution:** Temporal предоставляет масштабируемую и надежную среду выполнения функций, известную как Temporal Workflow Executions. Она гарантирует, что ваш код продолжит выполняться даже в случае сбоев или других проблем.
2. **Как это работает:** Temporal абстрагируется от сложностей построения масштабируемых распределенных систем. Это позволяет вам сосредоточиться на написании бизнес-логики, а не разбираться с инфраструктурными нюансами. С Temporal вы пишете код для положительных результатов, которых хотите достичь, а все остальное он берет на себя.
3. **Преимущества:**
  - **Быстрое внедрение функций:** Temporal исключает логику восстановления, обратные вызовы и таймеры из вашего кода, освобождая вас для создания большего количества функций.
  - **Надежность по умолчанию:** Temporal делает ваше программное обеспечение долговечным и отказоустойчивым, значительно сокращая количество отказов.
  - **Наглядность и понимание:** Temporal записывает каждое выполнение, предоставляя информацию об ошибках и производительности приложения.

Если вам надоело разбираться со сложностями инфраструктуры, Temporal может стать вашим новым лучшим другом!

### Event Sourcing (справка)

**Event Sourcing** — это паттерн, используемый для отслеживания изменений состояния приложения, который хранит их в виде последовательности событий. Вместо работы с статическими снимками данных мы используем Event Sourcing для захвата и сохранения событий, связанных с изменениями. Вот ключевые аспекты этого паттерна:

1. **События (Events):** Каждое изменение связано с событием, которое содержит метку времени и характер конкретного изменения. Вместо непосредственного изменения состояния объекта или базы данных мы записываем изменения в виде неизменяемых событий.
2. **Хранилище событий (Event Store):** События сохраняются в хранилище событий, которое действует как система записи (источник актуальных данных) о текущем состоянии данных. Хранилище событий обычно публикует события, чтобы потребители могли быть уведомлены и обработать их при необходимости.
3. **Преимущества Event Sourcing:**
  - Улучшенная производительность: Избегаем накладных расходов на обновление данных напрямую в хранилище.
  - Гибкость: События можно легко изменять в зависимости от потребностей фронтенда.
  - Полный аудит и история: Хранилище событий сохраняет полную историю изменений, что позволяет выполнять компенсирующие действия.

Event Sourcing может быть особенно полезен в сложных доменах, где требуется поддержка аудита, масштабируемости и надежности.

### CQRS (справка)

**CQRS** (Command Query Responsibility Segregation) — это архитектурный паттерн, который разделяет обработку команд (изменения данных) и запросов (чтение данных) на разные компоненты. Давайте рассмотрим его подробнее:

1. **Команды (Commands):** Команды отвечают за изменение данных. Они представляют задачи, а не просто операции над данными. Например, вместо “установки статуса бронирования на ‘Зарезервировано’”, мы используем команду “Забронировать номер в отеле”. Это позволяет сделать бизнес-логику более понятной и задаче-ориентированной.
2. **Запросы (Queries):** Запросы не изменяют состояние данных. Они возвращают DTO (Data Transfer Object), не содержащие доменной логики. Например, запрос на получение информации о бронировании номера в отеле.
3. **Преимущества CQRS:**
  - **Улучшенная производительность:** Разделение обработки команд и запросов позволяет оптимизировать каждую сторону независимо.
  - **Гибкость:** Модели для команд и запросов могут быть разными, что упрощает их развитие и поддержку.
  - **Асинхронность:** Команды можно обрабатывать асинхронно, например, через очереди сообщений.
4. **Использование с Event Sourcing:** CQRS часто сочетается с паттерном Event Sourcing, где события записываются в хранилище событий, а запросы читают данные из этого хранилища.

CQRS — это мощный инструмент для создания гибких и масштабируемых систем, особенно в сложных доменах!

### BDD (справка)

**Behavior-driven development (BDD)** — это методология разработки программного обеспечения, основанная на Agile. Она призвана обеспечить сотрудничество между разработчиками, тестировщиками и представителями заказчика, чтобы гарантировать ориентированные на пользователя результаты. Вот ключевые аспекты:

- **Язык домена:** BDD использует специализированный язык (DSL), который описывает поведение кода с помощью естественных конструкций (например, предложений на английском языке). Это позволяет формализовать общее понимание того, как приложение должно вести себя.
- **Процесс:** BDD преобразует язык DSL в выполнимые тесты, которые читаются как критерии приемки. Он расширяет практику TDD (test-driven development).
- **Фокус на пользователе:** BDD ориентирован на требования конечных пользователей и их взаимодействие с продуктом.

Применение BDD способствует лучшему пониманию требований, улучшает коммуникацию и помогает избегать проблем, связанных с автоматизированным тестированием.

### Нотация C4 (справка)

Нотация моделирования C4 — это метод визуализации архитектуры программного обеспечения, разработанный Саймоном Брауном. Она используется для создания диаграмм, описывающих архитектуру систем.

C4 появилась как реакция на сложность и непонятность традиционных архитектурных диаграмм. Саймон Браун предложил этот подход в начале 2010-х годов с целью упростить понимание архитектуры для всех участников команды разработки, включая разработчиков, тестировщиков, аналитиков, менеджеров и других заинтересованных сторон.

Название "C4" расшифровывается как:
- Context - Контекст, 
- Containers - Конейнеры,
- Components - Компоненты,
- Code - Код.

Эти четыре "C" представляют четыре уровня абстракции (представления), которые используются в этой нотации для визуализации архитектуры.

### Записи архитектурных решений (справка)

**Architecture Decision Records (ADR)** — это документы, которые фиксируют архитектурные решения, принимаемые в процессе проектирования и разработки программного обеспечения. Вот ключевые аспекты:

1. **Цель ADR:**
  - Зафиксировать ключевые архитектурные решения и контекст, в котором они были приняты.
  - Обосновать и объяснить последствия каждого решения.
2. **Применение ADR:**
  - Важный результат работы архитектора решений.
  - Документирует решения, принятые на разных этапах проектирования.
  - Помогает команде понимать причины и последствия архитектурных выборов.
3. **Содержание ADR:**
  - **Контекст:** Описание проблемы или вопроса, перед которым стояла команда.
  - **Решение:** Описание выбранного архитектурного решения.
  - **Обоснование:** Пояснение, почему это решение было принято.
  - **Последствия:** Указание на возможные последствия и ограничения.
4. **Примеры вопросов, которые могут привести к созданию ADR:**
  - Как обеспечить высокую доступность для Cloud SQL?
  - Как настроить GKE-кластеры для обеспечения надежности?
  - Следует ли использовать канареечные релизы?

ADR помогают командам принимать обоснованные архитектурные решения и сохранять их историю для будущих разработок.

### Нефункциональные требования (справка)

**Non-functional requirements (NFR)** определяют качества программной системы, которые не связаны непосредственно с ее функциональностью. В отличие от функциональных требований, которые описывают, что система должна делать, нефункциональные требования определяют, насколько эффективно она это должна делать. Эти атрибуты или характеристики системы охватывают такие области, как:

- **Производительность:** Скорость реакции системы на запросы.
- **Безопасность:** Меры для защиты от несанкционированного доступа и утечек данных.
- **Надежность:** Доступность и надежность системы.
- **Удобство использования:** Простота использования для конечных пользователей.
- **Масштабируемость:** Способность обрабатывать увеличение нагрузки.
- **Обслуживаемость:** Легкость обновления и модификации системы.
- **Тестируемость:** Возможность тестирования системы.
- **Переносимость:** Способность работать на разных платформах.

В целом нефункциональные требования направляют проектирование системы и часто служат ограничениями в соответствующих бэклогах, обеспечивая, что система соответствует необходимым качествам.

### Микросервисный паттерн Saga (справка)

**Паттерн Saga** — это способ управления согласованностью данных между микросервисами в сценариях распределенных транзакций. Сага представляет собой последовательность транзакций, обновляющих каждый сервис и публикующих сообщение или событие для запуска следующего шага транзакции. Если какой-то шаг не выполняется успешно, сага выполняет компенсирующие транзакции, которые противодействуют предыдущим изменениям и восстанавливают целостность данных. Этот паттерн обеспечивает надежность и целостность данных в микросервисной архитектуре.

**Temporal** предоставляет возможности для реализации микросервисного паттерна Saga. При использовании Temporal вы можете легко управлять согласованностью данных между микросервисами в распределенных транзакциях. Temporal позволяет поддерживать состояние, повторять операции и обеспечивать надежное выполнение каждого шага в распределенной транзакции. Это мощный инструмент для обработки долгосрочных транзакций и обеспечения целостности данных в микросервисной архитектуре.

### Highload-приёмы (справка)

Принципы и проблематика масштабирования слоёв данных, а также различные подходы к репликации:

1. **Вертикальное масштабирование (Vertical Scaling):**
  - **Описание:** Вертикальное масштабирование предполагает увеличение производительности путем добавления ресурсов (например, процессоров, памяти) на существующий сервер.
  - **Преимущества:**
    - Простота внедрения.
    - Отсутствие необходимости переписывать код при добавлении мощностей.
  - **Недостатки:**
    - Аппаратные ограничения одного сервера.
    - Высокая стоимость мощного оборудования.
    - Ограниченная масштабируемость.
2. **Горизонтальное масштабирование (Horizontal Scaling):**
  - **Описание:** Горизонтальное масштабирование — это увеличение производительности путем добавления дополнительных узлов инфраструктуры (например, серверов).
  - **Преимущества:**
    - Использование стандартного недорогого оборудования.
    - Высокая отказоустойчивость.
    - Нет необходимости в миграции инфраструктуры.
  - **Недостатки:**
    - Сложность управления большим количеством узлов.
    - Возможные проблемы с рассинхронизацией и задержками.
3. **Партиционирование (Partitioning):**
  - **Описание:** Разбиение данных на части по какому-либо признаку (например, чётность) внутри одной базы данных или таблицы.
  - **Преимущества:**
    - Увеличение производительности.
    - Возможность быстрого удаления неактуальных данных.
4. **Шардинг (Sharding):**
  - **Описание:** Части таблицы хранятся на разных физических серверах.
  - **Преимущества:**
    - Использование стандартного оборудования.
    - Высокая производительность.
5. **Репликация (Master-Slave):**
  - **Описание:** Копирование данных между серверами. Один сервер (мастер) используется для записи или изменения данных, а другие (слейвы) — для чтения и копирования информации с мастера.
  - **Преимущества:**
    - Большое количество копий данных.
    - Отказоустойчивость.
  - **Недостатки:**
    - Задержки при передаче данных.
    - Рассинхронизация.
6. **Репликация (No-Master):**
  - **Описание:** В этой модели отсутствует центральный мастер. Все устройства или процессы равноправны и обмениваются данными напрямую друг с другом. Например, P2P-сети (peer-to-peer) и блокчейн, где узлы обмениваются данными без центрального управления.
  - **Преимущества:**
    - Отказоустойчивость: Отсутствие единой точки отказа (мастера) повышает надежность системы.
    - Более равномерное распределение нагрузки: Все узлы могут обрабатывать запросы на чтение и запись, что улучшает производительность.
    - Простота масштабирования: Добавление новых узлов не требует переноса роли мастера.
  - **Недостатки:**
    - Сложность согласования данных: Без явного мастера необходимо решать проблемы согласования изменений и репликации.
    - Задержки при репликации: Обмен данными между узлами может вызывать задержки.
    - Сложность обработки конфликтов: При одновременных изменениях на разных узлах могут возникать конфликты.
  В целом, репликация данных без мастера — это компромисс между отказоустойчивостью и сложностью обработки данных. Выбор зависит от конкретных требований системы и её архитектуры.
7. **Репликация (Master-Master):**
  - **Описание:** В этой модели два или более устройства или процесса действуют как мастера и обмениваются данными между собой. Каждый мастер может записывать и читать данные.
  - **Преимущества:**
    - Отказоустойчивость: При сбое одного мастера другой может продолжать обслуживать запросы.
    - Более равномерное распределение нагрузки: Оба мастера могут обрабатывать запросы на чтение и запись, что улучшает производительность.
    - Простота масштабирования: Добавление новых мастеров не требует переноса роли.  
  - **Недостатки:**
    - Сложность согласования данных: Без явного мастера необходимо решать проблемы согласования изменений и репликации.
    - Задержки при репликации: Обмен данными между мастерами может вызывать задержки.
    - Сложность обработки конфликтов: При одновременных изменениях на разных мастерах могут возникать конфликты.
  В целом, репликация данных между мастерами — это компромисс между отказоустойчивостью и сложностью обработки данных. Выбор зависит от конкретных требований системы и её архитектуры.

### Понимание принципов DDD (справка)

**Domain-Driven Design (DDD)** — это подход к разработке программного обеспечения, который сосредотачивается на ядре домена вашего приложения. Вот несколько ключевых принципов DDD:

1. **Фокус на ядре домена и доменной логике:** DDD предполагает, что вы активно изучаете и понимаете ключевые аспекты бизнес-домена, чтобы точно моделировать его в вашем коде.
2. **Основа сложных дизайнов на моделях домена:** Вместо того чтобы начинать с абстрактных архитектурных решений, DDD рекомендует строить сложные дизайны на основе моделей, которые отражают реальные аспекты домена.
3. **Сотрудничество с экспертами домена:** Важно взаимодействовать с экспертами домена (например, бизнес-аналитиками или представителями бизнеса), чтобы уточнить модель приложения и решить возникающие доменные проблемы.

### Data-modelling (справка)

**Паттерны моделирования данных** — это ключевые стратегии и структуры, которые помогают организовать данные в системе. Вот несколько популярных паттернов:

1. **Стандартная модель:** Этот паттерн охватывает основные аспекты бизнеса, такие как связи между людьми и организациями, иерархия, различные типы продуктов, соглашения между сторонами и географические местоположения.
2. **Параметры:** Этот паттерн помогает определить и разграничить разные типы продуктов. Например, параметр “емкость” может описывать котел, а параметр “процентная ставка” — сберегательный счет.
3. **Построение с использованием паттернов:** При проектировании приложения разработчики часто сталкиваются с необходимостью моделировать данные, учитывая структуру организации, продукта и потребителей.